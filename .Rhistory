lambda = median(pv$score^2)/0.456
lambda #1.06
adj.p.values = pchisq(pv$score^2/lambda, df = 1, lower = FALSE)
hist(adj.p.values)
hist(adj.p.values)
#Note that these calibrated scores are similar as pv$calibrated.pvalue
hist(pv$calibrated.pvalue)
#Try higher value of GIF -- looking for flat distribution with peak near zero
adj.p.values = pchisq(pv$score^2/1.15, df = 1, lower = FALSE)
hist(adj.p.values)
#Try lower value of GIF -- looking for flat distribution with peak near zero
adj.p.values = pchisq(pv$score^2/0.95, df = 1, lower = FALSE)
hist(adj.p.values)
#Try slightly higher value of GIF -- looking for flat distribution with peak near zero
adj.p.values = pchisq(pv$score^2/1.05, df = 1, lower = FALSE)
hist(adj.p.values)
#THIS IS SHOWING THAT THE GIF CALIBRATION IN THE ALGORITHM IS Good
#However, the (slightly) lower values have a correct distribution under null model
#Try at GIF = 0.95
adj.p.values = pchisq(pv$score^2/0.95, df = 1, lower = FALSE)
hist(adj.p.values)
#Read scaffold lengths
scf_lens = read.table("data/Nf_SPANDx_all_seqs/scaffold_lengths.csv", sep = ",", header = F)
colnames(scf_lens) = c("scaffold", "length")
#Join with actual position and chromosome
pv.with_pos = data.frame(calibrated.p = pv$calibrated.pvalue, effect_size = pv$B, SNP_pos, man.adj.p = adj.p.values) %>% left_join(., scf_lens)
#############################
#Outlier tests
# identify the 95% percentile
my_threshold <- quantile((pv.with_pos )$calibrated.p, 0.025, na.rm = T) #removed the filter by 100000, can do this later for plotting but it does not seem good to do before outlier ID; %>% filter(length > 100000)
# make an outlier column in the data.frame
pv.with_pos <- pv.with_pos %>% mutate(outlier = ifelse(calibrated.p < my_threshold, "outlier", "background"))
#Number of outliers
pv.with_pos %>% group_by(outlier) %>% tally()
#FDR correction
#This is based on the auto calibartion
pv.with_pos$FDR.p = p.adjust(pv.with_pos$calibrated.p, method = "fdr", n = length(pv.with_pos$calibrated.p))
pv.with_pos <- pv.with_pos %>% mutate(FDR.sig = ifelse(FDR.p < 0.1, "sig", "background"))
pv.with_pos %>% group_by(FDR.sig) %>% tally()
#FDR correction
#This is based on the manual GIF adjustment
pv.with_pos$FDR.p.man = p.adjust(pv.with_pos$man.adj.p, method = "fdr", n = length(pv.with_pos$man.adj.p))
pv.with_pos <- pv.with_pos %>% mutate(FDR.sig.man = ifelse(FDR.p.man < 0.05, "sig", "background"))
pv.with_pos %>% group_by(FDR.sig.man) %>% tally()
########################
#Rerun the FDR correction to have automatically calculated p-vals
########################
#FDR correction
#This is based on the auto calibartion
pv.with_pos$FDR.p = p.adjust(pv.with_pos$calibrated.p, method = "fdr", n = length(pv.with_pos$calibrated.p))
pv.with_pos <- pv.with_pos %>% mutate(FDR.sig = ifelse(FDR.p < 0.1, "sig", "background"))
pv.with_pos %>% group_by(FDR.sig) %>% tally()
write.table(pv.with_pos, "data/Nf_LFMM_tables/tmin_lfmm.txt", quote = F, row.names = F, sep = "\t")
#Basic plot
ggplot(pv.with_pos %>% filter(length > 100000), aes(x = position/10^6, y = calibrated.p)) +
#facet_wrap(~scaffold) +
facet_grid(. ~ scaffold, scales = "free_x", space='free') +
geom_point(alpha = 0.5, size = 1) +
#scale_x_continuous(labels = fancy_scientific, breaks = c(1, seq(from = 10^6, to = 6*10^6, by = 10^6)) ) +
scale_x_continuous(breaks = c(0, seq(from = 1, to = 6, by = 1)) ) +
scale_y_continuous(trans = reverselog_trans(10), labels = trans_format('log10',math_format(10^.x))) +
my_gg_theme +
labs(x = "Position (Mbp)", y = "P value") +
theme(
strip.text.x = element_blank(),
axis.text.x = element_text(size = 8)
#axis.text.x = element_text(angle = 85, size = 10, hjust = 1)
)
#Colored by outliers
ggplot(pv.with_pos %>% filter(length > 100000), aes(x = position/10^6, y = calibrated.p, color = outlier)) +
#facet_wrap(~scaffold) +
facet_grid(. ~ scaffold, scales = "free_x", space='free') +
geom_point(alpha = 0.5, size = 1) +
#scale_x_continuous(labels = fancy_scientific, breaks = c(1, seq(from = 10^6, to = 6*10^6, by = 10^6)) ) +
scale_x_continuous(breaks = c(0, seq(from = 1, to = 6, by = 1)) ) +
scale_y_continuous(trans = reverselog_trans(10), labels = trans_format('log10',math_format(10^.x)), guide = "none") +
scale_color_manual(values = c("grey", "black")) +
my_gg_theme +
labs(x = "Position (Mbp)", y = "P value") +
theme(
strip.text.x = element_blank(),
axis.text.x = element_text(size = 8)
#axis.text.x = element_text(angle = 85, size = 10, hjust = 1)
)
#FDR with auto corrected P (algorithm GIF)
p1 = ggplot(pv.with_pos %>% filter(length > 100000), aes(x = position/10^6, y = calibrated.p, color = FDR.sig)) +
#facet_wrap(~scaffold) +
facet_grid(. ~ scaffold, scales = "free_x", space='free') +
geom_point(alpha = 0.5, size = 1) +
#scale_x_continuous(labels = fancy_scientific, breaks = c(1, seq(from = 10^6, to = 6*10^6, by = 10^6)) ) +
scale_x_continuous(breaks = c(0, seq(from = 1, to = 6, by = 1)) ) +
scale_y_continuous(trans = reverselog_trans(10), labels = trans_format('log10',math_format(10^.x))) +
scale_color_manual(values = c("grey", "black"), guide = "none") +
my_gg_theme +
labs(x = "Position (Mbp)", y = "") +
theme(
strip.text.x = element_blank(),
#axis.text.x = element_text(size = 8)
axis.text.x = element_blank(),
axis.title.x = element_blank()
)
p1
p2 = ggplot(pv.with_pos %>% filter(length > 100000), aes(x = position/10^6, y = man.adj.p, color = FDR.sig.man)) +
#facet_wrap(~scaffold) +
facet_grid(. ~ scaffold, scales = "free_x", space='free') +
geom_point(alpha = 0.5, size = 1) +
#scale_x_continuous(labels = fancy_scientific, breaks = c(1, seq(from = 10^6, to = 6*10^6, by = 10^6)) ) +
scale_x_continuous(breaks = c(0, seq(from = 1, to = 6, by = 1)) ) +
scale_y_continuous(trans = reverselog_trans(10), labels = trans_format('log10',math_format(10^.x))) +
scale_color_manual(values = c("grey", "black"), guide = "none") +
my_gg_theme +
labs(x = "Position (Mbp)", y = "") +
theme(
strip.text.x = element_blank(),
#axis.text.x = element_text(size = 8)
axis.text.x = element_blank(),
axis.title.x = element_blank()
)
p2
#FDR correction maunally adjusted P (GIF = 0.95)
ggplot(pv.with_pos %>% filter(length > 100000), aes(x = position/10^6, y = man.adj.p, color = FDR.sig.man)) +
#facet_wrap(~scaffold) +
facet_grid(. ~ scaffold, scales = "free_x", space='free') +
geom_point(alpha = 0.5, size = 1) +
#scale_x_continuous(labels = fancy_scientific, breaks = c(1, seq(from = 10^6, to = 6*10^6, by = 10^6)) ) +
scale_x_continuous(breaks = c(0, seq(from = 1, to = 6, by = 1)) ) +
scale_y_continuous(trans = reverselog_trans(10), labels = trans_format('log10',math_format(10^.x))) +
scale_color_manual(values = c("grey", "black"), guide = "none") +
my_gg_theme +
labs(x = "Position (Mbp)", y = "P value") +
theme(
strip.text.x = element_blank(),
axis.text.x = element_text(size = 8)
#axis.text.x = element_text(angle = 85, size = 10, hjust = 1)
)
pdf("figures/LFMM.tmin.pdf", width = 18, height = 4)
p1
p2
dev.off()
#variable for test
X = sample_metadata.site_info$tmax
#LFMM ridge
mod.lfmm = lfmm_ridge(Y = Y, X = X, K = 4) #using K = 4 based on PCA and pop structure analyses
pv <- lfmm_test(Y = Y,
X = X,
lfmm = mod.lfmm,
calibrate = "gif")
#Example plots
plot(-log10(pv$calibrated.pvalue),
pch = 19,
cex = .3,
xlab = "Probe", ylab = "-Log P",
col = "grey")
plot((pv$B),
pch = 19,
cex = .3,
xlab = "Probe", ylab = "Effect size",
col = "grey")
#Computing genomic inflation factor (GIF) based on calibrated z-scores (http://membres-timc.imag.fr/Olivier.Francois/lfmm/files/LEA_1.html) and Francois et al. 2016
lambda = median(pv$score^2)/0.456
lambda #1.06
lambda #1.12
adj.p.values = pchisq(pv$score^2/lambda, df = 1, lower = FALSE)
hist(adj.p.values)
#Computing genomic inflation factor (GIF) based on calibrated z-scores (http://membres-timc.imag.fr/Olivier.Francois/lfmm/files/LEA_1.html) and Francois et al. 2016
lambda = median(pv$score^2)/0.456
lambda #1.12
adj.p.values = pchisq(pv$score^2/lambda, df = 1, lower = FALSE)
hist(adj.p.values)
#Note that these calibrated scores are similar as pv$calibrated.pvalue
hist(pv$calibrated.pvalue)
#Try higher value of GIF -- looking for flat distribution with peak near zero
adj.p.values = pchisq(pv$score^2/1.15, df = 1, lower = FALSE)
hist(adj.p.values)
#Try lower value of GIF -- looking for flat distribution with peak near zero
adj.p.values = pchisq(pv$score^2/0.95, df = 1, lower = FALSE)
hist(adj.p.values)
#Try lower value of GIF -- looking for flat distribution with peak near zero
adj.p.values = pchisq(pv$score^2/1.05, df = 1, lower = FALSE)
hist(adj.p.values)
#THIS IS SHOWING THAT THE GIF CALIBRATION IN THE ALGORITHM IS Good
#However, the (slightly) lower values have a correct distribution under null model
#Try at GIF = 1.05
adj.p.values = pchisq(pv$score^2/1.05, df = 1, lower = FALSE)
hist(adj.p.values)
#Read scaffold lengths
scf_lens = read.table("data/Nf_SPANDx_all_seqs/scaffold_lengths.csv", sep = ",", header = F)
colnames(scf_lens) = c("scaffold", "length")
#Join with actual position and chromosome
pv.with_pos = data.frame(calibrated.p = pv$calibrated.pvalue, effect_size = pv$B, SNP_pos, man.adj.p = adj.p.values) %>% left_join(., scf_lens)
#############################
#Outlier tests
# identify the 95% percentile
my_threshold <- quantile((pv.with_pos )$calibrated.p, 0.025, na.rm = T) #removed the filter by 100000, can do this later for plotting but it does not seem good to do before outlier ID; %>% filter(length > 100000)
# make an outlier column in the data.frame
pv.with_pos <- pv.with_pos %>% mutate(outlier = ifelse(calibrated.p < my_threshold, "outlier", "background"))
#Number of outliers
pv.with_pos %>% group_by(outlier) %>% tally()
#FDR correction
#This is based on the auto calibartion
pv.with_pos$FDR.p = p.adjust(pv.with_pos$calibrated.p, method = "fdr", n = length(pv.with_pos$calibrated.p))
pv.with_pos <- pv.with_pos %>% mutate(FDR.sig = ifelse(FDR.p < 0.1, "sig", "background"))
pv.with_pos %>% group_by(FDR.sig) %>% tally()
#FDR correction
#This is based on the manual GIF adjustment
pv.with_pos$FDR.p.man = p.adjust(pv.with_pos$man.adj.p, method = "fdr", n = length(pv.with_pos$man.adj.p))
pv.with_pos <- pv.with_pos %>% mutate(FDR.sig.man = ifelse(FDR.p.man < 0.05, "sig", "background"))
pv.with_pos %>% group_by(FDR.sig.man) %>% tally()
########################
#Rerun the FDR correction to have automatically calculated p-vals
########################
#FDR correction
#This is based on the auto calibartion
pv.with_pos$FDR.p = p.adjust(pv.with_pos$calibrated.p, method = "fdr", n = length(pv.with_pos$calibrated.p))
pv.with_pos <- pv.with_pos %>% mutate(FDR.sig = ifelse(FDR.p < 0.1, "sig", "background"))
pv.with_pos %>% group_by(FDR.sig) %>% tally()
write.table(pv.with_pos, "data/Nf_LFMM_tables/tmax_lfmm.txt", quote = F, row.names = F, sep = "\t")
#Basic plot
ggplot(pv.with_pos %>% filter(length > 100000), aes(x = position/10^6, y = calibrated.p)) +
#facet_wrap(~scaffold) +
facet_grid(. ~ scaffold, scales = "free_x", space='free') +
geom_point(alpha = 0.5, size = 1) +
#scale_x_continuous(labels = fancy_scientific, breaks = c(1, seq(from = 10^6, to = 6*10^6, by = 10^6)) ) +
scale_x_continuous(breaks = c(0, seq(from = 1, to = 6, by = 1)) ) +
scale_y_continuous(trans = reverselog_trans(10), labels = trans_format('log10',math_format(10^.x))) +
my_gg_theme +
labs(x = "Position (Mbp)", y = "P value") +
theme(
strip.text.x = element_blank(),
axis.text.x = element_text(size = 8)
#axis.text.x = element_text(angle = 85, size = 10, hjust = 1)
)
#Colored by outliers
ggplot(pv.with_pos %>% filter(length > 100000), aes(x = position/10^6, y = calibrated.p, color = outlier)) +
#facet_wrap(~scaffold) +
facet_grid(. ~ scaffold, scales = "free_x", space='free') +
geom_point(alpha = 0.5, size = 1) +
#scale_x_continuous(labels = fancy_scientific, breaks = c(1, seq(from = 10^6, to = 6*10^6, by = 10^6)) ) +
scale_x_continuous(breaks = c(0, seq(from = 1, to = 6, by = 1)) ) +
scale_y_continuous(trans = reverselog_trans(10), labels = trans_format('log10',math_format(10^.x)), guide = "none") +
scale_color_manual(values = c("grey", "black")) +
my_gg_theme +
labs(x = "Position (Mbp)", y = "P value") +
theme(
strip.text.x = element_blank(),
axis.text.x = element_text(size = 8)
#axis.text.x = element_text(angle = 85, size = 10, hjust = 1)
)
#FDR with auto corrected P (algorithm GIF)
p1 = ggplot(pv.with_pos %>% filter(length > 100000), aes(x = position/10^6, y = calibrated.p, color = FDR.sig)) +
#facet_wrap(~scaffold) +
facet_grid(. ~ scaffold, scales = "free_x", space='free') +
geom_point(alpha = 0.5, size = 1) +
#scale_x_continuous(labels = fancy_scientific, breaks = c(1, seq(from = 10^6, to = 6*10^6, by = 10^6)) ) +
scale_x_continuous(breaks = c(0, seq(from = 1, to = 6, by = 1)) ) +
scale_y_continuous(trans = reverselog_trans(10), labels = trans_format('log10',math_format(10^.x))) +
scale_color_manual(values = c("grey", "black"), guide = "none") +
my_gg_theme +
labs(x = "Position (Mbp)", y = "") +
theme(
strip.text.x = element_blank(),
#axis.text.x = element_text(size = 8)
axis.text.x = element_blank(),
axis.title.x = element_blank()
)
p1
p2 = ggplot(pv.with_pos %>% filter(length > 100000), aes(x = position/10^6, y = man.adj.p, color = FDR.sig.man)) +
#facet_wrap(~scaffold) +
facet_grid(. ~ scaffold, scales = "free_x", space='free') +
geom_point(alpha = 0.5, size = 1) +
#scale_x_continuous(labels = fancy_scientific, breaks = c(1, seq(from = 10^6, to = 6*10^6, by = 10^6)) ) +
scale_x_continuous(breaks = c(0, seq(from = 1, to = 6, by = 1)) ) +
scale_y_continuous(trans = reverselog_trans(10), labels = trans_format('log10',math_format(10^.x))) +
scale_color_manual(values = c("grey", "black"), guide = "none") +
my_gg_theme +
labs(x = "Position (Mbp)", y = "") +
theme(
strip.text.x = element_blank(),
#axis.text.x = element_text(size = 8)
axis.text.x = element_blank(),
axis.title.x = element_blank()
)
p2
#FDR correction maunally adjusted P (GIF = 0.95)
ggplot(pv.with_pos %>% filter(length > 100000), aes(x = position/10^6, y = man.adj.p, color = FDR.sig.man)) +
#facet_wrap(~scaffold) +
facet_grid(. ~ scaffold, scales = "free_x", space='free') +
geom_point(alpha = 0.5, size = 1) +
#scale_x_continuous(labels = fancy_scientific, breaks = c(1, seq(from = 10^6, to = 6*10^6, by = 10^6)) ) +
scale_x_continuous(breaks = c(0, seq(from = 1, to = 6, by = 1)) ) +
scale_y_continuous(trans = reverselog_trans(10), labels = trans_format('log10',math_format(10^.x))) +
scale_color_manual(values = c("grey", "black"), guide = "none") +
my_gg_theme +
labs(x = "Position (Mbp)", y = "P value") +
theme(
strip.text.x = element_blank(),
axis.text.x = element_text(size = 8)
#axis.text.x = element_text(angle = 85, size = 10, hjust = 1)
)
pdf("figures/LFMM.tmax.pdf", width = 18, height = 4)
p1
p2
dev.off()
(200*10^9)/100
(2*10^9)/45*10^6
3000/100
30*25
30*40
1200+750
4.444444e+13
(2*10^9)/(45*10^6)
30*28 + 40*28
70*28
(2*10^9)/(43*10^6)
3000*.3
3000*.25
40*28
q(save="no")
library(dplyr)
library(data.table)
#function for nearest neighbor
#we will have already searched for SNPs *within* genes so the we can then search for start sites > then pos else stop sites < pos for the nearest neighbor match
#genes down stream of SNPs will have positive distance and upstream will have negative distance
#i.e., start - SNPpos OR stop - SNPpos
nearest_gene = function(snpPos = NULL, gff = NULL){
#new col for distances
gff$dist = vector(mode = "numeric", length = nrow(gff))
#calculate distances
gff$dist = ifelse(gff$start > snpPos, gff$start - snpPos, gff$stop - snpPos)
#filter to minimum absolute distance and return the resulting df
#dplyr way
#return( filter(gff, abs(dist) == min(abs(gff$dist))) )
#DT way
return(
gff[
abs(dist) == min(abs(gff$dist))
]
)
}
#import gff (gene positions) contig name, gene ID, start site, stop site
gff = read.csv("data/Nf_SPANDx_all_seqs/makerFINAL.all.mRNA_ONLY.gff", sep = "\t")
head(gff)
#import LFMM results
lfmm_results = read.table("data/Nf_LFMM_tables/tmax_lfmm.txt", header = T)
colnames(lfmm_results)
#filter for SNPs with sig relationship to variable
lfmm_results.sig = lfmm_results %>% filter(FDR.sig == "sig") %>% select(scaffold, position)
nrow(lfmm_results.sig)
head(lfmm_results.sig)
#new col in gff table for snp counts
gff$sig_SNP_count = rep(0, nrow(gff))
#new cols in SNP table for whether a gene was found for a snp and type of relationship (no.match, in.gene, nearest), gene id of match, and distance of match (if nearest neighbor)
lfmm_results.sig$match.type = vector(mode = "character", length = nrow(lfmm_results.sig))
lfmm_results.sig$geneID = vector(mode = "character", length = nrow(lfmm_results.sig))
lfmm_results.sig$distance = vector(mode = "numeric", length = nrow(lfmm_results.sig))
#set to data.table to using rolling count update
gff.dt = as.data.table(gff)
#Loop through SNPs
#Need to add gene name matches to SNP table (also deal with case of >1 match)
#Also add matched SNP count to genes
for(i in 1:nrow(lfmm_results.sig)){
#filter for a gene that contains the SNP within start and stop positions
temp = gff.dt[
contig == lfmm_results.sig$scaffold[i] &
start <=  lfmm_results.sig$position[i] &
stop >= lfmm_results.sig$position[i]
]
#check if there is a matching gene. If not go to next
if(nrow(temp) == 1){ #need the if in cases where there is no in-gene match
gff.dt[ #the first lines are dt conditionals
contig == lfmm_results.sig$scaffold[i] &
start <=  lfmm_results.sig$position[i] &
stop >= lfmm_results.sig$position[i],
#rolling count update
sig_SNP_count := sig_SNP_count + 1
]
lfmm_results.sig$match.type[i] = "in.gene"
lfmm_results.sig$geneID[i] = temp$geneID
lfmm_results.sig$distance[i] = 0
}else{ #if there is no within gene match filter to the nearest gene(s)
#filter to the correct scaffold
temp2 = gff.dt[
contig == lfmm_results.sig$scaffold[i]
]
#calculate distance to genes and return the nearest neighbor(s)
temp2.match = nearest_gene(lfmm_results.sig$position[i], temp2)
#Need to account for possible ties in distance. First look for single match
if(nrow(temp2.match) == 1){
print(nrow(temp2.match))
gff.dt[
geneID == temp2.match$geneID, #conditional filter to gene ID
sig_SNP_count := sig_SNP_count + 1 #update count
]
lfmm_results.sig$match.type[i] = "nearest"
lfmm_results.sig$geneID[i] = temp2.match$geneID
lfmm_results.sig$distance[i] = temp2.match$dist
}else if(nrow(temp2.match) > 0){ #if there are no matches we will update below
print(nrow(temp2.match))
gff.dt[
geneID == temp2.match$geneID, #conditional filter to gene ID
sig_SNP_count := sig_SNP_count + 1 #update count
]
lfmm_results.sig$match.type[i] = "nearest.multiple"
lfmm_results.sig$geneID[i] = temp2.match$geneID
lfmm_results.sig$distance[i] = temp2.match$dist
}else{
lfmm_results.sig$match.type[i] = "no.match"
lfmm_results.sig$geneID[i] = "no.match"
lfmm_results.sig$distance[i] = 0
}
}#end alternative to within gene
}#end for loop
lfmm_results.sig
#import LFMM results
lfmm_results = read.table("data/Nf_LFMM_tables/tmin_lfmm.txt", header = T)
colnames(lfmm_results)
#filter for SNPs with sig relationship to variable
lfmm_results.sig = lfmm_results %>% filter(FDR.sig == "sig") %>% select(scaffold, position)
nrow(lfmm_results.sig)
head(lfmm_results.sig)
#new col in gff table for snp counts
gff$sig_SNP_count = rep(0, nrow(gff))
#new cols in SNP table for whether a gene was found for a snp and type of relationship (no.match, in.gene, nearest), gene id of match, and distance of match (if nearest neighbor)
lfmm_results.sig$match.type = vector(mode = "character", length = nrow(lfmm_results.sig))
lfmm_results.sig$geneID = vector(mode = "character", length = nrow(lfmm_results.sig))
lfmm_results.sig$distance = vector(mode = "numeric", length = nrow(lfmm_results.sig))
#set to data.table to using rolling count update
gff.dt = as.data.table(gff)
#Loop through SNPs
#Need to add gene name matches to SNP table (also deal with case of >1 match)
#Also add matched SNP count to genes
for(i in 1:nrow(lfmm_results.sig)){
#filter for a gene that contains the SNP within start and stop positions
temp = gff.dt[
contig == lfmm_results.sig$scaffold[i] &
start <=  lfmm_results.sig$position[i] &
stop >= lfmm_results.sig$position[i]
]
#check if there is a matching gene. If not go to next
if(nrow(temp) == 1){ #need the if in cases where there is no in-gene match
gff.dt[ #the first lines are dt conditionals
contig == lfmm_results.sig$scaffold[i] &
start <=  lfmm_results.sig$position[i] &
stop >= lfmm_results.sig$position[i],
#rolling count update
sig_SNP_count := sig_SNP_count + 1
]
lfmm_results.sig$match.type[i] = "in.gene"
lfmm_results.sig$geneID[i] = temp$geneID
lfmm_results.sig$distance[i] = 0
}else{ #if there is no within gene match filter to the nearest gene(s)
#filter to the correct scaffold
temp2 = gff.dt[
contig == lfmm_results.sig$scaffold[i]
]
#calculate distance to genes and return the nearest neighbor(s)
temp2.match = nearest_gene(lfmm_results.sig$position[i], temp2)
#Need to account for possible ties in distance. First look for single match
if(nrow(temp2.match) == 1){
print(nrow(temp2.match))
gff.dt[
geneID == temp2.match$geneID, #conditional filter to gene ID
sig_SNP_count := sig_SNP_count + 1 #update count
]
lfmm_results.sig$match.type[i] = "nearest"
lfmm_results.sig$geneID[i] = temp2.match$geneID
lfmm_results.sig$distance[i] = temp2.match$dist
}else if(nrow(temp2.match) > 0){ #if there are no matches we will update below
print(nrow(temp2.match))
gff.dt[
geneID == temp2.match$geneID, #conditional filter to gene ID
sig_SNP_count := sig_SNP_count + 1 #update count
]
lfmm_results.sig$match.type[i] = "nearest.multiple"
lfmm_results.sig$geneID[i] = temp2.match$geneID
lfmm_results.sig$distance[i] = temp2.match$dist
}else{
lfmm_results.sig$match.type[i] = "no.match"
lfmm_results.sig$geneID[i] = "no.match"
lfmm_results.sig$distance[i] = 0
}
}#end alternative to within gene
}#end for loop
lfmm_results.sig$match.type %>% unique
lfmm_results.sig$distance %>% abs %>% mean #2252
lfmm_results.sig$distance %>% abs %>% median #2252
lfmm_results.sig$distance %>% abs %>% median #2142
lfmm_results.sig %>% filter(distance > 0 | distance < 0) %>% pull(distance) %>% abs %>% range #2142 to 2362
lfmm_results.sig %>% filter(match.type == "in.gene") %>% nrow #0
lfmm_results.sig %>% nrow #0 of 2 in gene
gff.dt %>% filter(sig_SNP_count > 0) #2 associated with SNPs
gff.dt %>% filter(sig_SNP_count > 1) #1 have >1 SNP
#######################
#plots of snp distance
#######################
library(ggplot2)
p1 = ggplot(lfmm_results.sig, aes(x = distance)) +
geom_histogram(breaks = seq(-25000, 25000, 250)) +
theme_bw() +
labs(x = "Gene distance from SNP (bp)", y = "Number SNPs (bin width 250 bp)")
p1
pdf("figures/SNP_distance.tmin.pdf")
p1
dev.off()
##############################
#Write results tables
##############################
write.table(gff.dt %>% filter(sig_SNP_count > 0), "data/Nf_LFMM_tables/tmin.gene_SNP_hits.txt", col.names = T, row.names = F, sep = "\t", quote = F)
write.table(lfmm_results.sig, "data/Nf_LFMM_tables/tmin.SNPs.gene_found.nearest_neighbors.txt", col.names = T, row.names = F, sep = "\t", quote = F)
write.table(gff.dt %>% filter(sig_SNP_count > 0) %>% select(geneID), "data/Nf_LFMM_tables/tmin.geneIDs.nearest_neighbors.txt", col.names = F, row.names = F, sep = "\t", quote = F)
p1
q(save="no")
